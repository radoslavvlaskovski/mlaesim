from etc import reader
from system_analysis import clustering
from pprint import pprint
import numpy as np

vm_start_latency = 7
reclassify_latency = 20

def classify(current_data):
    thresholds = clustering.clustering(current_data, 3)
    return thresholds

def predictor(regression_data, current_step, steps_advance):

    return regression_data[current_step + steps_advance][1]

def run(update_freq = 0, steps_advance = 0, starting_step = 0):

    cluster_data = reader.create_data_points_no_requests()
    current_data = cluster_data[:starting_step]
    regression_data = reader.create_regression_dp()

    current_step = starting_step
    current_vm_number = cluster_data[starting_step][1]
    last_step = len(cluster_data) - 1

    next_vm_start_time = -1
    vm_start_in_progress = False
    reclassify_countdown = reclassify_latency

    # Initial classification
    thresholds = classify(current_data)

    # save the data generated by the algorithm
    output_data = list()

    while(current_step <= last_step):

        # Run what happens at a single time step
        # compute current mean cpu
        current_mean_cpu_usage = (cluster_data[current_step][0] * cluster_data[current_step][1]) / current_vm_number

        # Check if new VM started
        if vm_start_in_progress:
            if next_vm_start_time == current_step:
                current_vm_number +=1
                vm_start_in_progress = False

        # If needed reclassify data
        if reclassify_countdown > 0:
            reclassify_countdown -= 1
        else:
            reclassify_countdown = reclassify_latency
            thresholds = classify(current_data)

        # Predict
        if last_step > current_step + steps_advance:
            prediction = predictor(regression_data, current_step, steps_advance) / current_vm_number
            # Make a decision
            decision = clustering.make_decision(thresholds, current_vm_number, prediction)
            # SCALE IN
            if decision == 0 and current_vm_number > 1:
                current_vm_number -= 1
            # SCALE OUT
            if decision == 1 and vm_start_in_progress == False:
                vm_start_in_progress = True
                next_vm_start_time = current_step + vm_start_latency

        # Update data go to next step
        current_data = np.append(current_data, [[current_mean_cpu_usage, current_vm_number]], axis=0)
        output_data.append([current_mean_cpu_usage, current_vm_number])
        current_step += 1

    compare(cluster_data, output_data, starting_step)

def compare(cluster_data, output_data, starting_step):
    output_data = np.array(output_data)
    sim_avg_cpu = np.mean(output_data.T[0])
    avg_cpu = np.mean(cluster_data[starting_step:].T[0])
    sim_avg_vms = np.mean(output_data.T[1])
    avg_vms = np.mean(cluster_data[starting_step:].T[1])

    sim_scaling_procedures = 0
    for i in range(0, len(output_data) - 1):
        if output_data[i][1] != output_data[i+1][1]:
            sim_scaling_procedures += 1
    real_scaling_procedures = 0
    for i in range(0, len(cluster_data) - 1):
        if cluster_data[i][1] != cluster_data[i + 1][1]:
            real_scaling_procedures += 1


    print(" AVG CPU REAL: " + str(avg_cpu))
    print(" AVG CPU SIM: " + str(sim_avg_cpu))
    print(" AVG VM REAL: " + str(avg_vms))
    print(" AVG VM SIM: " + str(sim_avg_vms))
    print(" COUNT SCALING REAL: " + str(real_scaling_procedures))
    print(" COUNT SCALING SIM: " + str(sim_scaling_procedures))

run(starting_step=1000, steps_advance=10)